#############################
#	Fonctionnement HTTP		#
#############################

Un client envoie une requete HTTP a un serveur qui lui renvoie une reponse

# STRUCTURE REQUETE

GET /index.html HTTP/1.1     ← ligne de requête
Host: www.exemple.com        ← header
User-Agent: Mozilla/5.0      ← header
Accept: text/html            ← header
Accept-Language: fr-FR,...   ← header
Connection: keep-alive       ← header
                             ← ligne vide
[pas de body]                ← corps vide

_ La ligne de requete est l'element principal qui correspond a l'action qu'on a envie de realiser.
	methode, ressource, version
	GET : demande une ressource
	POST : envoie des donnees au serveur (creation ou traitement)
	DELETE : supprimer une ressource

_ Le header est un ensemble d'option et de precision.
	type de contenu, tailles, cookies...

_ Le body est l'ensemble des donnees envoyees par le client au server (utilise seulement si necessaire). Avec un GET il sera vide tandis qu'avec un POST ou PUT il y  aura quelque chose.
POST /form HTTP/1.1
Host: www.exemple.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 27

nom=Luc&message=Bonjour


# STRUCTURE REPONSE

HTTP/1.1 200 OK							← ligne de status
Date: Mon, 11 Aug 2025 15:20:00 GMT		← header
Server: MonServeurHTTP/1.0				← header
Content-Type: text/html; charset=UTF-8	← header
Content-Length: 125						← header
Connection: keep-alive					← header
										← ligne vide
<!DOCTYPE html>							← corps
<html>									← corps
<head><title>Exemple</title></head>		← corps
<body>									← corps
<h1>Bienvenue sur mon site</h1>			← corps
<p>Ceci est une page HTML.</p>			← corps
</body>									← corps
</html>									← corps

_ La ligne de status est le code de retour avec un message.
	Code important :
		200 : OK
		404 : Not Found, le serveur ne trouve pas ce qui est demande
		405 : Method not allowed, le serveur connait la requete mais elle n'est pas supportee par la ressource cible
		500 : Internal Server Error, le serveur a un probleme inattendu qui l'empeche de repondre a la requete

_ Le header donne des informations sur la reponse.

_ Le body est le contenu renvoye par le serveur.



Niveau 3 — Communication Client → Serveur
Exercice 1 — Serveur HTTP minimal (GET)

But : comprendre comment lire une requête HTTP brute et renvoyer une réponse formatée.

    Étapes :

        Partir de ton code « chat room minimal » mais supprimer la partie broadcast.

        Quand recv() reçoit une requête :

            Lire la chaîne complète (elle commence par GET / HTTP/1.1).

            Ignorer le parsing pour l’instant.

            Envoyer une réponse brute :

        HTTP/1.1 200 OK\r\n
        Content-Type: text/plain\r\n
        Content-Length: 13\r\n
        \r\n
        Hello, world!

    Fermer la connexion après envoi (mode HTTP/1.0).

Test :

    curl -v http://localhost:8080/

Exercice 2 — Serveur HTTP statique

But : servir un fichier du disque.

    Étapes :

        Extraire le chemin demandé de la requête (GET /index.html HTTP/1.1).

        Si /, remplacer par /index.html.

        Lire le fichier avec open() + read().

        Déterminer le Content-Type selon extension :

            .html → text/html

            .txt → text/plain

            .jpg → image/jpeg

            etc.

        Construire la réponse HTTP avec Content-Length = taille du fichier.

        Envoyer le header + contenu du fichier.

        Si le fichier n’existe pas → envoyer un 404 Not Found.

    Test :

    echo "<h1>Hello</h1>" > index.html
    curl -v http://localhost:8080/

Niveau 4 — Fonctions avancées
Exercice 3 — Serveur non-bloquant

But : éviter que recv() ou send() bloquent le programme.

    Étapes :

        Utiliser fcntl(sock, F_SETFL, O_NONBLOCK) sur le socket principal et tous les clients.

        Continuer à utiliser poll() pour savoir quand lire/écrire.

        Gérer le fait que recv() peut retourner -1 avec errno == EAGAIN ou EWOULDBLOCK.

Exercice 4 — Timeouts de connexion

But : fermer les clients inactifs.

    Étapes :

        Stocker l’horodatage du dernier message reçu par chaque client.

        Avec poll(timeout), vérifier régulièrement si time(NULL) - last_activity > X.

        Si oui → fermer la connexion.

Exercice 5 — Mini-CGI

But : exécuter un script et renvoyer sa sortie.

    Étapes :

        Si le chemin demandé est /script :

            Créer un pipe.

            fork().

                Dans le fils : rediriger stdout vers le pipe et faire execve() sur script.sh ou python3 script.py.

                Dans le parent : lire la sortie via le pipe.

        Construire une réponse HTTP avec cette sortie comme body.

        Tester avec :

curl http://localhost:8080/script
