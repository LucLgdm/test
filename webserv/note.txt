#############################
#	Fonctionnement HTTP		#
#############################

Un client envoie une requete HTTP a un serveur qui lui renvoie une reponse

# STRUCTURE REQUETE

GET /index.html HTTP/1.1     â† ligne de requÃªte
Host: www.exemple.com        â† header
User-Agent: Mozilla/5.0      â† header
Accept: text/html            â† header
Accept-Language: fr-FR,...   â† header
Connection: keep-alive       â† header
                             â† ligne vide
[pas de body]                â† corps vide

_ La ligne de requete est l'element principal qui correspond a l'action qu'on a envie de realiser.
	methode, ressource, version
	GET : demande une ressource
	POST : envoie des donnees au serveur (creation ou traitement)
	DELETE : supprimer une ressource

_ Le header est un ensemble d'option et de precision.
	type de contenu, tailles, cookies...

_ Le body est l'ensemble des donnees envoyees par le client au server (utilise seulement si necessaire). Avec un GET il sera vide tandis qu'avec un POST ou PUT il y  aura quelque chose.
POST /form HTTP/1.1
Host: www.exemple.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 27

nom=Luc&message=Bonjour


# STRUCTURE REPONSE

HTTP/1.1 200 OK							â† ligne de status
Date: Mon, 11 Aug 2025 15:20:00 GMT		â† header
Server: MonServeurHTTP/1.0				â† header
Content-Type: text/html; charset=UTF-8	â† header
Content-Length: 125						â† header
Connection: keep-alive					â† header
										â† ligne vide
<!DOCTYPE html>							â† corps
<html>									â† corps
<head><title>Exemple</title></head>		â† corps
<body>									â† corps
<h1>Bienvenue sur mon site</h1>			â† corps
<p>Ceci est une page HTML.</p>			â† corps
</body>									â† corps
</html>									â† corps

_ La ligne de status est le code de retour avec un message.
	Code important :
		200 : OK
		404 : Not Found, le serveur ne trouve pas ce qui est demande
		405 : Method not allowed, le serveur connait la requete mais elle n'est pas supportee par la ressource cible
		500 : Internal Server Error, le serveur a un probleme inattendu qui l'empeche de repondre a la requete

_ Le header donne des informations sur la reponse.

_ Le body est le contenu renvoye par le serveur.



Niveau 3 â€” Communication Client â†’ Serveur
Exercice 1 â€” Serveur HTTP minimal (GET)

But : comprendre comment lire une requÃªte HTTP brute et renvoyer une rÃ©ponse formatÃ©e.

    Ã‰tapes :

        Partir de ton code Â« chat room minimal Â» mais supprimer la partie broadcast.

        Quand recv() reÃ§oit une requÃªte :

            Lire la chaÃ®ne complÃ¨te (elle commence par GET / HTTP/1.1).

            Ignorer le parsing pour lâ€™instant.

            Envoyer une rÃ©ponse brute :

        HTTP/1.1 200 OK\r\n
        Content-Type: text/plain\r\n
        Content-Length: 13\r\n
        \r\n
        Hello, world!

    Fermer la connexion aprÃ¨s envoi (mode HTTP/1.0).

Test :

    curl -v http://localhost:8080/

Exercice 2 â€” Serveur HTTP statique

But : servir un fichier du disque.

    Ã‰tapes :

        Extraire le chemin demandÃ© de la requÃªte (GET /index.html HTTP/1.1).

        Si /, remplacer par /index.html.

        Lire le fichier avec open() + read().

        DÃ©terminer le Content-Type selon extension :

            .html â†’ text/html

            .txt â†’ text/plain

            .jpg â†’ image/jpeg

            etc.

        Construire la rÃ©ponse HTTP avec Content-Length = taille du fichier.

        Envoyer le header + contenu du fichier.

        Si le fichier nâ€™existe pas â†’ envoyer un 404 Not Found.

    Test :

    echo "<h1>Hello</h1>" > index.html
    curl -v http://localhost:8080/

Niveau 4 â€” Fonctions avancÃ©es
Exercice 3 â€” Serveur non-bloquant

But : Ã©viter que recv() ou send() bloquent le programme.

    Ã‰tapes :

        Utiliser fcntl(sock, F_SETFL, O_NONBLOCK) sur le socket principal et tous les clients.

        Continuer Ã  utiliser poll() pour savoir quand lire/Ã©crire.

        GÃ©rer le fait que recv() peut retourner -1 avec errno == EAGAIN ou EWOULDBLOCK.

Exercice 4 â€” Timeouts de connexion

But : fermer les clients inactifs.

    Ã‰tapes :

        Stocker lâ€™horodatage du dernier message reÃ§u par chaque client.

        Avec poll(timeout), vÃ©rifier rÃ©guliÃ¨rement si time(NULL) - last_activity > X.

        Si oui â†’ fermer la connexion.

Exercice 5 â€” Mini-CGI

But : exÃ©cuter un script et renvoyer sa sortie.

    Ã‰tapes :

        Si le chemin demandÃ© est /script :

            CrÃ©er un pipe.

            fork().

                Dans le fils : rediriger stdout vers le pipe et faire execve() sur script.sh ou python3 script.py.

                Dans le parent : lire la sortie via le pipe.

        Construire une rÃ©ponse HTTP avec cette sortie comme body.

        Tester avec :

curl http://localhost:8080/script


1. Cas simple (un seul CGI)

	Tu vois que lâ€™URL demandÃ©e est /script.py.
	Tu fork(), dup2(pipe[1], STDOUT_FILENO) dans le fils.
	Tu fais execve("/usr/bin/python3", ["python3", "script.py"], env).
	Le pÃ¨re lit dans le pipe et renvoie la sortie HTTP.

2. Cas multi-CGI (plusieurs scripts)

	ğŸ‘‰ La diffÃ©rence, câ€™est juste :
	plusieurs chemins ( /script1.py, /script2.sh, /cgi-bin/machin â€¦ ).
	donc tu dois faire une table de correspondance entre lâ€™URL demandÃ©e et le binaire Ã  exÃ©cuter.
	Exemple :
		struct CgiConfig {
			std::string path;       // chemin URL ex: "/script1.py"
			std::string exec_path;  // interprÃ©teur ex: "/usr/bin/python3"
			std::string file;       // fichier script ex: "script1.py"
		};
	Tu gardes Ã§a dans un std::vector<CgiConfig> chargÃ© depuis ton fichier de config.

3. Gestion simultanÃ©e

	Comme ton serveur est non-bloquant avec poll(), tu peux avoir plusieurs pipes actifs en mÃªme temps (un pour chaque CGI lancÃ©).
	Chaque client qui appelle un CGI â†’ tu fork(), tu lâ€™associes Ã  un pipe, et tu continues la boucle poll.
	Quand le pipe devient lisible, tu sais que la sortie du CGI est prÃªte et tu envoies la rÃ©ponse au client concernÃ©.

4. Ce qui change par rapport Ã  1 seul CGI

	Tu as une map fd â†’ client pour savoir quel client attend la sortie du CGI.
	Tu as une map pid â†’ CGI en cours pour gÃ©rer la fin des processus enfants (Ã©viter les zombies avec waitpid).
	Tu dois construire dynamiquement argv et envp selon le script exÃ©cutÃ© et la requÃªte.