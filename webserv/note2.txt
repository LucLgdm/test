1. Parsing du fichier de configuration

	Lire le fichier .conf donné en argument.
	Stocker les informations dans des structures :
		ServerConfig : ports (listen), host, root, index, error_page, client_max_body_size, etc.
		LocationConfig : path, methods autorisées, règles CGI, redirections, upload store, etc.
	Supporter plusieurs serveurs virtuels (plusieurs blocs server).
	Associer Host: des requêtes HTTP avec le bon serveur.

2. Mise en place du serveur

	Créer un socket par listen.
	bind() + listen().
	Passer en mode non-bloquant (fcntl).
	Ajouter chaque socket d’écoute dans poll() (ou select()).
	Préparer les réponses d’erreur par défaut (400, 404, 405, 500, etc.).

3. Boucle d’événements

	poll() surveille :
		nouveaux clients sur sockets d’écoute,
		sockets clients pour lecture/écriture.
	Quand un client se connecte : accept() et ajouter au poll.
	Stocker un objet Client par connexion avec :
		fd,
		buffer d’entrée,
		état de parsing,
		buffer de sortie,
		last_activity (timestamp).

4. Parsing des requêtes HTTP

	Lire depuis le socket client (non bloquant).
	Parser la requête :
		Request line : GET /path HTTP/1.1
		Headers : Host:, Content-Length, Transfer-Encoding, Connection, Cookie:…
		Body (si Content-Length ou chunked).
	Vérifier que la méthode est autorisée (sinon → 405 Method Not Allowed).
	Vérifier la taille max du body (413 Payload Too Large si > client_max_body_size).

5. Routing & Mapping

	Associer l’URI demandée avec la bonne LocationConfig.
	Déterminer la ressource cible :
		fichier statique (root + uri),
		index (si répertoire),
		CGI (si configuré),
		redirection (si configurée).
	Vérifier les permissions (méthodes autorisées).

6. Gestion des méthodes HTTP

	GET : lire et envoyer fichier.
	HEAD : identique à GET mais sans body.
	POST :
		soit écrire dans un fichier (upload),
		soit envoyer en entrée à un CGI.
	DELETE : supprimer fichier si autorisé.

7. Gestion des CGI

	Déterminer si la requête doit passer par un script (ex: /cgi-bin/script.py).
	Créer un pipe pour rediriger la sortie du script.
	fork() + execve() du script, en passant les variables d’environnement CGI (REQUEST_METHOD, QUERY_STRING, CONTENT_LENGTH, etc.).
	Lire la sortie du script via le pipe.
	Construire une réponse HTTP avec cette sortie.

8. Réponses HTTP

	Générer une réponse bien formée :
		HTTP/1.1 200 OK\r\n
		Content-Type: text/html\r\n
		Content-Length: 123\r\n
		\r\n
		[body]
	Gérer les erreurs personnalisées (error_page 404 /404.html).
	Gérer redirects (301, 302).
	Gérer cookies :
	Set-Cookie dans réponse,
	Cookie dans requête.

9. Gestion des connexions

	Timeout : si time(NULL) - last_activity > client_timeout, fermer connexion.
	Respecter le header Connection:
	keep-alive → garder la connexion ouverte pour plusieurs requêtes.
	close (ou HTTP/1.0) → fermer après la réponse.